# 逃逸分析
逃逸分析是jvm用于确定被创建的对象作用域的一项方法，可以让jvm决定该对象创建的位置。

## 逃逸状态
1. 全局逃逸  
  某个对象完全逃出当前方法或者线程，包括以下几种场景：
  - 对象是一个静态变量
  - 对象是一个已经发生逃逸的对象
  - 对象作为当前方法的返回值

2. 参数逃逸  
  某个对象在当前方法中作为其他方法的参数/引用传递。通过分析被调用字节码确定。
  
3. 未逃逸

## 优化内容
- 锁消除  
  线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。  
  
  例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。  
  
  锁消除在`JDK8`中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上，JVM参数如下：
    - 开启锁消除：-XX:+EliminateLocks
    - 关闭锁消除：-XX:-EliminateLocks
     
- 标量替换
  首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。
  
  对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。
  
  这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。
  
  标量替换的 JVM 参数如下：
  
  开启标量替换：-XX:+EliminateAllocations
  关闭标量替换：-XX:-EliminateAllocations
  显示标量替换详情：-XX:+PrintEliminateAllocations
  标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。

- 栈上分配
  当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。
  
## 总结
逃逸分析是jvm优化对象创建位置的一项技术，平时应该在代码编写时多注意对象的作用域，让作用域尽可能减小。